import os
import sys
import time
import fsspec
import pathlib

from datetime import datetime
from collections.abc import Mapping
from collections import Counter

from igit.storage import object_store


# from .object_store import ObjectStore
from .models import ObjectRef, Commit, Tag, AnnotatedTag, User, CommitRef
from .refs import Refs
from .trees import BaseTree, collect_intervals
from .diffs import Diff, has_diffs
from .config import Config
from .utils import roundrobin

# from .object_store import ObjectStore
from .refs import Refs
from .trees import collect_intervals, BaseTree, LabelTree
from .models import ObjectRef, CommitRef, TreeRef, RepoIndex, User
# from .igit import IGit
from .storage import SubfolderMapper, IGitObjectStore, ObjectStorage, BinaryStorage
from .utils import ls
from .visualizations import echarts_graph, get_pipeline_dag
from .config import Config
from .encryption import ENCRYPTORS
from .constants import CONFIG_NAME
from tokenize import tokenize
from igit import storage

class CommitError(RuntimeError):
    pass

class MergeError(CommitError):
    pass


def get_object_ref(key, otype, size=-1):
    """
    get an object reference

    Args:
        key :
        otype :
        size : Defaults to -1

    (Generated by docly)
    """
    for class_ in ObjectRef.__subclasses__():
        if class_.otype == otype:
            return class_(key=key, size=size)
    raise KeyError(otype)

class IRepo:
    config: Config
#     description: str
#     hooks: dict
#     info: str
    objects: IGitObjectStore
    refs: Refs
    index: ObjectRef = None
    working_tree: BaseTree = None

    def __init__(self, config, key=None, **kwargs):
        if isinstance(config,  pathlib.Path):
            config = str(config)
        if isinstance(config, str):
            config = os.path.join(config, CONFIG_NAME)
            with fsspec.open(config, "rb") as f:
                config = Config.parse_raw(f.read())
        if not isinstance(config, Config):
            raise TypeError("config must be a valid path or Config object")

        repo = fsspec.get_mapper(config.root_path, **kwargs)
        
        encryptor_class = ENCRYPTORS.get(config.encryption, None)
        if encryptor_class is not None and key is not None:
            encryptor = encryptor_class(key)
        else:
            encryptor = None

        igit_folder = SubfolderMapper(config.igit_path, repo)

        objects_store = BinaryStorage(igit_folder, 
                     compressor=config.compression,
                     encryptor=encryptor)
        objects = IGitObjectStore(d=objects_store,
                                 serializer=config.serializer,)
        refs = Refs(SubfolderMapper(config.refs_path, repo))

        self.config = config
        self.index = ObjectStorage(SubfolderMapper('index', repo), serializer=config.serializer,)
        self.objects = objects
        self.refs = refs
        self.fstore = repo

    def __getitem__(self, name):
        return self.INDEX_TREE[name]

    def __setitem__(self, key, value):
        self.add(**{key:value})

    @classmethod
    def init(cls, path, main_branch="master",
             username=None, email=None, connection_kwargs={}, **kwargs):
        if isinstance(path,  pathlib.Path):
            path = "file://" + str(path)
        if isinstance(path, str):
            storage = fsspec.get_mapper(path)
        elif isinstance(path, fsspec.mapping.FSMap):
            storage = path
        else:
            raise TypeError("repo must be a valid fsspec path or FSMap")
        
        if CONFIG_NAME in storage:
            raise ValueError(f"igit repository already exists in path.")

        kwargs = dict(kwargs)
        
        key = kwargs.pop("key", None)
        user = User.get_user(username=username, email=email)
        config = Config(HEAD=main_branch, main_branch=main_branch,
                         user=user, root_path=path, **kwargs)
        storage[CONFIG_NAME] = config.json(indent=3).encode()
        
        return cls(config, key=key, connection_kwargs=connection_kwargs)
        

    @classmethod
    def clone(cls, source, target=None, branch="master", **kwargs):
        if target is None:
            target = "file://" + source.rpartition("/")[-1]
        repo = cls.init(target, **kwargs)
        source = cls(source)
        head = source.refs.heads[branch]
        for obj in head.walk(source.objects):
            repo.objects.hash_object(obj)

        repo.refs.heads[branch] = head
        repo.config = source.config
        repo.config.root_path = target
        repo.config.HEAD = branch
        repo.checkout(branch)
        return repo

    @classmethod
    def clone(cls, url):
        pass
    
    @property
    def WORKING_TREE(self):
        if self.working_tree is None:
            raise TypeError('Bare repo has no working tree')
        return self.working_tree

    @property
    def HEAD(self):
        if not len(self.refs.heads):
            return None
        if self.config.HEAD in self.refs.heads:
            return self.refs.heads[self.config.HEAD]
        if self.config.HEAD in self.refs.tags:
            return self.refs.tags[self.config.HEAD]
        return CommitRef(key=self.config.HEAD)

    @property
    def HEAD_TREE(self):
        if self.HEAD is None:
            return None
        return self.HEAD.deref_tree(self.objects)

    @property
    def INDEX(self):
        return self.index

    @property
    def INDEX_TREE(self):
        return LabelTree.from_paths_dict(self.index)
    
    @property
    def detached(self):
        return self.config.HEAD not in self.refs.heads

    @property
    def dirty(self):
        if self.WORKING_TREE is None:
            return False
        return (self.WORKING_TREE != self.INDEX_TREE)

    def status(self):
        pass

    def cat_object(self, ref, otype="blob",):
        if isinstance(ref, ObjectRef):
            return ref.deref(self.objects)
        if isinstance(ref, str):
            return get_object_ref(ref, otype=otype).deref(self.objects)
        else:
            raise KeyError(ref)

    def hash_object(self, obj):
        return self.objects.hash_object(obj)

    def update_index(self, *keys):
        pass

    def write_tree(self):
        pass

    def add(self, **kwargs):
        index = self.INDEX_TREE
        for k,obj in kwargs.items():
            if not self.objects.consistent_hash(obj):
                raise ValueError(f"{k} of type {type(obj)} cannot be consistently hashed.")
            index[k] = obj
        index.sync(self.index)
        return index

    def rm(self, *keys):
        index = self.INDEX_TREE
        for k in keys:
            if k in index:
                del index[k]
        index.sync(self.index)
        return index

    def commit(self, message, author=None, commiter=None):
        if author is None:
            author = self.config.user
        elif isinstance(author, dict):
            author = User(**author)
        if commiter is None:
            commiter = self.config.user
        elif isinstance(commiter, dict):
            commiter = User(**commiter)
        parents = ()
        if self.HEAD is not None:
            parents = (self.HEAD, )
        tree = self.objects.hash_object(self.INDEX_TREE)
        commit = Commit(parents=parents, tree=tree, message=message,
                        author=author, commiter=commiter, timestamp=int(time.time()))
        cref = self.hash_object(commit)
        self.refs.heads[self.config.HEAD] = cref
        return cref
    
    def checkout(self, key, branch=False):
        if self.dirty:
            raise CommitError("You have uncomitted changes in your staging area.")
        if branch:
            self.branch(key)
        if key in self.refs.heads:
            ref = self.refs.heads[key]
        elif key in self.refs.tags:
            ref = self.refs.tags[key]
        elif isinstance(key, CommitRef):
            ref = key
        elif isinstance(key, str):
            ref = CommitRef(key=key)
        else:
            raise TypeError(f'cannot locate branch or commit referenced by {key}')
        commit = ref.deref(self.objects)
        tree = commit.tree.deref(self.objects)
        self.config.HEAD = key
        self.working_tree = tree
        return tree

    def branch(self, name=None):
        if name is None:
            return self.config.HEAD
        if name in self.refs.heads:
            raise ValueError("A branch with this name already exists.")
        if self.HEAD is None:
            raise CommitError('Cant branch from non-existing branch.')
        ref = self.HEAD
        self.refs.heads[name] = ref
        return self.checkout(name)

    def tag(self, name, annotated=False, tagger=None, message=""):
        cref = self.HEAD
        if annotated:
            if tagger is None:
                tagger = self.config.user
            atag = AnnotatedTag(key=cref.key, tag=name, tagger=tagger, message=message)
            cref = self.hash_object(atag)
        tag = Tag(key=cref.key)
        self.refs.tags[name] = tag
        return tag

    def merge(self, other, message, commiter=None):
        if self.dirty:
            raise MergeError("You have unstaged changes in your working tree.")
        common = self.find_common_ancestor(self.HEAD, other).deref_tree(self.objects)
        ours = self.get_branch_tree(self.HEAD)

        incoming = self.get_branch_tree(other)

        if len( common.diff(ours).diff_edits(common.diff(incoming)) ):
            raise MergeError(f"Cannot merge with {other}, conflicts exist")
        
        if commiter is None:
            commiter = self.config.user
        elif isinstance(commiter, dict):
            commiter = User(**commiter)

        parents = (self.HEAD, self.get_ref(other))
        merged = self.HEAD_TREE.apply_diff(common.diff(incoming))
        merged_ref = merged.hash_tree(self.objects)

        commit = Commit(parents=parents, tree=merged_ref, message=message,
                         commiter=commiter, timestamp=int(time.time()))
        cref = self.hash_object(commit)
        self.refs.heads[self.config.HEAD] = cref
        return cref
    
    def fetch(self, remote=None):
        pass
    
    def pull(self, remote=None):
        pass
        
    def push(self, remote=None):
        pass
    
    def fs_check(self):
        pass

    def rev_parse(self, key):
        pass

    def commit_graph(self):
        return self.HEAD.digraph(self.objects)

    def show_commits(self):
        return self.HEAD.visualize_heritage(self.objects)

    def cat_tree(self, ref, otype="blob"):
        if isinstance(ref, str):
            ref = self.get_ref(ref)
        obj = ref.deref(self.objects)
        if isinstance(obj, Commit):
            obj = obj.tree.deref(self.objects)
        if not isinstance(obj, BaseTree):
            raise ValueError(f"reference {ref} does not point to a tree or commit.")
        return obj

    def diff(self, ref1, ref2, otype="commit"):
        tree1 = ref1.deref(self.objects)
        tree2 = ref2.deref(self.objects)
        diffs = tree1.diff(tree2)
        return Diff(old=str(ref1), new=str(ref2), diffs=diffs)

    def get_branch_tree(self, branch):
        if isinstance(branch, CommitRef):
                ref = branch
        elif isinstance(branch, str):
            if branch in self.refs.heads:
                ref = self.refs.heads[branch]
            else:
                ref = self.get_ref(branch)
        return ref.deref_tree(self.objects)

    def get_ref(self, key):
        if isinstance(key, ObjectRef):
            return key
        if key in self.refs.heads:
            return self.refs.heads[key]
        if key in self.refs.tags:
            return self.refs.tags[key]

        obj = self.objects.fuzzy_get(key)
        ref = self.objects.hash_object(obj)
        return ref

    def find_common_ancestor(self, *branches):
        refs = []
        for branch in branches:
            if isinstance(branch, CommitRef):
                ref = branch
            elif isinstance(branch, str):
                if branch in self.refs.heads:
                    ref = self.refs.heads[branch]
                else:
                    ref = self.get_ref(branch)
            refs.append(ref)

        keys = Counter()
        for cref in roundrobin(*[r.walk_parents(self.objects) for r in refs]):
            keys[cref.key] += 1
            if keys[cref.key] == len(refs):
                return cref

    def serve(self):
        import uvicorn
        import igit
        app = igit.server.make_app(self.location)
        uvicorn.run(app, host="0.0.0.0", port=5000, log_level="info")

    def save(self):
        # self.ostore["working_tree"] = self.WORKING_TREE
        self.fstore[CONFIG_NAME] = self.config.json(indent=3).encode()
      
    def load(self):
        # tree = self.ostore.get("working_tree", None)
        # if tree is not None:
            # self.working_tree = tree
        self.config = Config.parse_raw(self.fstore[CONFIG_NAME])

    def browse_history(self):
        if self.HEAD is None:
            import panel as pn
            return pn.Column()
        pipeline, dag = get_pipeline_dag(self.HEAD, self.objects)
        pipeline.define_graph(dag)
        return pipeline
    

    def browse_files(self):
        from fsspec.gui import FileSelector
        sel = FileSelector()

        protocol = self.fstore.fs.protocol
        if isinstance(protocol, tuple):
            protocol = protocol[-1]
        sel.protocol.value = sel.prev_protocol = protocol
        sel._fs = self.fstore.fs
        sel.url.value = self.fstore.root
        sel.go_clicked()
        return sel